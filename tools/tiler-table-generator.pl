#!/usr/bin/env perl
use List::Util qw(reduce);
use Getopt::Long;
use sexpr;
use warnings;
use strict;

# This script takes the tiler grammar file (x64.tiles)
# and produces tiler tables.
my $PREFIX = "MVM_JIT_";
my $VARNAME = "MVM_jit_tile_";
my $DEBUG   = 0;
my ($INFILE, $OUTFILE, $TESTING);
GetOptions(
    'debug' => \$DEBUG,
    'testing' => \$TESTING,
    'input=s' => \$INFILE,
    'output=s' => \$OUTFILE,
    'prefix=s' => \$PREFIX,
);
if (!defined $INFILE && @ARGV && -f $ARGV[0]) {
    $INFILE = shift @ARGV;
}

# Collect rules -> form list, table;
# list contains 'shallow' nodes, maps rulenr -> rule
# indirectly create rulenr -> terminal
# table contains head -> rulenr

# Read the expression tree node types in correct order
my @expr_ops;
{
    open my $expr_h, '<', 'src/jit/expr.h' or die "Could not open expression definition file";
    while (<$expr_h>) {
        last if m/^#define MVM_JIT_IR_OPS\(_\) \\/;
    }
    while(!eof($expr_h)) {
        my $line = <$expr_h>;
        chomp $line;
        last unless $line =~ m/\\$/;
        next unless $line =~ m/_\((\w+), \d+, \d+, \w+\)/;
        my $op = substr($line, $-[1], $+[1]-$-[1]);
        push @expr_ops, $op;
    }
    close $expr_h;
}

# Collect rules from the grammar
my (@rules, @names, @paths, @curpath);
sub add_rule {
    my ($fragment, $terminal, $cost, @trace) = @_;
    my $list = [];
    # replace all sublist with pseudorules
    for (my $i = 0; $i < @$fragment; $i++) {
        my $item = $fragment->[$i];
        if (ref($item) eq 'ARRAY') {
            # create pseudorule
            my $label = sprintf('L%dP%d', scalar @rules, scalar @trace);
            # divide costs
            $cost /= 2;
            add_rule($item, $label, $cost, @trace, $i);
            push @$list, $label;
        } else {
            push @curpath, @trace, $i, -1 if $i > 0;
            push @$list, $item;
        }
    }
    push @curpath, @trace, -1 if @$fragment == 1 && @trace > 0;
    # NB - only top-level fragments are associated with tiles.
    my $rulenr = scalar @rules;
    push @rules, [$list, uc $terminal, $cost];
    return $rulenr;
}

my $input;
if (defined $INFILE) {
    open $input, '<', $INFILE or die "Could not open $INFILE";
} elsif (! -t STDIN) {
    $input = \*STDIN;
} elsif ($TESTING) {
    $input = \*DATA;
} else {
    die "No input provided\n";
}

my $parser = sexpr->parser($input);
while (my $tree = $parser->read) {
    my ($keyword, $name, $fragment, $terminal, $cost) = @$tree;
    if ($keyword eq 'tile:') {
        @curpath = ();
        my $rulenr = add_rule($fragment, $terminal, $cost);
        $names[$rulenr] = $name;
        $paths[$rulenr] = [@curpath, -1];
    }
}
close $input;

# generate topological graph
my (%heads, %deps, %block);
for (my $rule_nr = 0; $rule_nr < @rules; $rule_nr++) {
    my $frag = $rules[$rule_nr][0];
    my $head = $frag->[0];
    my $term = $rules[$rule_nr][1];
    push @{$heads{$head}}, $rule_nr;
    for (my $i = 1; $i < @$frag; $i++) {
        my $item = $frag->[$i];
        if ($item ne $term) {
            # add dependency to resolution of term
            push @{$deps{$item}}, $rule_nr;
            $block{$head}->{$item}++;
        }
    }
}


#
# Generate rulesets conservatively.
#
# The code generator tries to map tree elements to generation rules.
# In many cases, a given tree element can be mapped to many rules at
# the same time (the ruleset). Such rulesets represent the states in
# the matching DFA. State transitions are effected by means of a
# three-dimensional table of [ head x ruleset x ruleset ], which is
# why we want to keep the number of rulesets as small as possible.
#
# The smallest number possible is of course only those rulesets that
# can be generated by the DFA. Thus, we first need to generate the
# DFA table to find the rulesets required for the DFA table. To solve
# this circular problem, observe that the rulesets generated by a head
# can only depend on the terminals that the children of the head refer
# to. And that it cannot matter *which* ruleset generates these terminals,
# just as long as *all* terminals are generated by a ruleset.  Hence,
# we can use topological sort to find the 'generatable' subset of heads,
# and use these to generate the rulesets by head.
#
# I'm fairly sure this can be optimized; it is not necessary to loop
# through all rulesets generating a terminal, but only through all
# rulesets generating any of the combinations of terminals that can be
# placed somewhere.
#

sub sortn {
    # numeric sort
    sort { $a <=> $b } @_;
}

my @order;
my %candidates;
my @rulesets;
my %inversed;
for my $head (keys %heads) {
    push @order, $head unless $block{$head};
}

while (@order) {
    my $head = shift @order;
    print "Generating rulesets for $head\n" if $DEBUG;
    my $rule_nrs = $heads{$head};
    # hold map of head,ruleset,ruleset -> rules
    my %table;
    # construct all applicable rules based on the current known rulesets
    for my $rule_nr (@$rule_nrs) {
        my ($c1, $c2) = @{$rules[$rule_nr][0]}[1,2];
        if (defined $c2) {
            for my $rs1 (@{$candidates{$c1}}) {
                for my $rs2 (@{$candidates{$c2}}) {
                    $table{$head,$rs1,$rs2}->{$rule_nr} = 1;
                }
            }
        } elsif (defined $c1) {
            for my $rs1 (@{$candidates{$c1}}) {
                $table{$head,$rs1,-1}->{$rule_nr} = 1;
            }
        } else {
            $table{$head,-1,-1}->{$rule_nr} = 1;
        }
    }
    # now add all distinct sets of rules to the rule sets
    print "Rulesets for $head: " if $DEBUG;
    my %provided;
    for my $generated (values %table) {
        my @rule_nrs = sortn keys %$generated;
        my $key = join $;, @rule_nrs;
        next if defined $inversed{$key};
        my @terms = map { $rules[$_][1] } @rule_nrs;
        my $ruleset_nr = scalar @rulesets;
        push @rulesets, [@rule_nrs];
        $inversed{$key} = $ruleset_nr;
        print '(', join ', ', @rule_nrs, '); ' if $DEBUG;
        for (@terms) {
            push @{$candidates{$_}}, $ruleset_nr;
            $provided{$_} = 1;
        }
    }
    print "\n" if $DEBUG;;

    # Unblock the waiting elements.
    for my $term (keys %provided) {
        next unless defined $deps{$term};
        for (my $i = 0; $i < @{$deps{$term}}; $i++) {
            my $rule = $deps{$term}[$i];
            my $head = $rules[$rule][0][0];
            next unless $block{$head}{$term};
            delete $block{$head}{$term};
            if (!%{$block{$head}}) {
                push @order, $head;
                delete $block{$head};
            }
        }
        delete $deps{$term};
    }
}


print "Now we have ", scalar @rulesets, " different rulesets\n" if $DEBUG;


# Calculate minimum cost rule out of a ruleset and a terminal
sub min_cost {
    my ($ruleset_nr, $term) = @_;
    my @applicable = grep { $rules[$_][1] eq $term } @{$rulesets[$ruleset_nr]};
    my $min = reduce { $rules[$a][2] < $rules[$b][2] ? $a : $b } @applicable;
    return $min;
}

# Generate a table, indexed by head, ruleset_nr, ruleset_nr -> ruleset
# and another table, head, ruleset_nr, ruleset_nr -> rule
my %table;
my %trans;
for (my $rule_nr = 0; $rule_nr < @rules; $rule_nr++) {
    my ($frag, $term, $cost) = @{$rules[$rule_nr]};
    my ($head, $c1, $c2)     = @$frag;
    if (defined $c1) {
        my $cand1 = $candidates{$c1};
        if (defined $c2) {
            # binary
            my $cand2   = $candidates{$c2};
            for my $rs1 (@$cand1) {
                my $lc1 = min_cost($rs1, $c1);
                for my $rs2 (@$cand2) {
                    my $lc2 = min_cost($rs2, $c2);
                    $table{$head}{$rs1}{$rs2} = [$rule_nr, $lc1, $lc2] if ($term eq 'reg' || $term eq 'void');
                    $trans{$head,$rs1,$rs2}->{$rule_nr} = 1;
                }
            }
        } else {
            # unary
            for my $rs1 (@$cand1) {
                my $lc1 = min_cost($rs1, $c1);
                $table{$head}{$rs1} = [$rule_nr, $lc1] if ($term eq 'reg' || $term eq 'void');
                $trans{$head,$rs1}->{$rule_nr} = 1;
            }
        }
    } else {
        # no children
        $table{$head} = [$rule_nr] if $term eq 'reg';
        $trans{$head}->{$rule_nr} = 1;
    }
}

# translate rule lists to rulesets
my %states;
while (my ($table_key, $applicable) = each(%trans)) {
    my @rule_nrs = sortn keys %$applicable;
    my $ruleset_key = join($;, @rule_nrs);
    my $ruleset_nr  = $inversed{$ruleset_key};
    my ($head, $rs1, $rs2) = split /$;/, $table_key;
    if (defined $rs1) {
        if (defined $rs2) {
            $states{$head}{$rs1}{$rs2} = $ruleset_nr;
        } else {
            $states{$head}{$rs1} = $ruleset_nr;
        }
    } else {
        $states{$head} = $ruleset_nr;
    }
}




if ($TESTING) {
    ## right, now for a testrun - can we actually tile a tree with this thing
    my ($tree, $rest) = sexpr->parse('(add (load (const)) (const))');
    sub tile {
        my $tree = shift;
        my ($head, $c1, $c2) = @$tree;
        my ($ruleset_nr, $optimum);
        if (defined $c2) {
            my $l1 = tile($c1);
            my $l2 = tile($c2);
            $ruleset_nr = $states{$head}{$l1}{$l2};
            $optimum    = $table{$head}{$l1}{$l2};
        } elsif (defined $c1) {
            my $l1 = tile($c1);
            $ruleset_nr = $states{$head}{$l1};
            $optimum    = $table{$head}{$l1};
        } else {
            $ruleset_nr = $states{$head};
            $optimum    = $table{$head};
        }
        print "Tiled $head to ", sexpr::encode($optimum),sexpr::encode($rules[$optimum->[0]][0]), "\n";
        return $ruleset_nr;
    }
    tile $tree;
    ($tree, $rest) = sexpr->parse('(add (const) (load (addr (stack))))');
    tile $tree;
} else {
    # dump table
    my $output;
    if (defined $OUTFILE) {
        open $output, '>', $OUTFILE or die "Could not open $OUTFILE";
    } else {
        $output = \*STDOUT;
    }

    print $output <<"HEADER";
/* FILE AUTOGENERATED BY $0. DO NOT EDIT.
 * Define tables for tiler DFA. */
HEADER
    print $output "static const MVMint8 ${VARNAME}paths[] = {\n   ";
    my @path_idx;
    my ($numchar, $idx) = (4, 0);
    for (my $i = 0; $i < @paths; $i++) {
        next unless defined $paths[$i];
        my $trace = $paths[$i];
        for my $step (@$trace) {
            my $str = " $step,";
            $numchar += length($str);
            if ($numchar >= 79) {
                print $output "\n   ";
                $numchar = 4 + length($str)
            }
            print $output $str;
        }
        $path_idx[$i] = $idx;
        $idx += @$trace;
    }
    print $output "\n};\n";

    print $output "static const MVMJitTile ${VARNAME}table[] = {\n";
    for (my $i = 0; $i < @rules; $i++) {
        if (defined $names[$i]) {
            print $output "    { \&${VARNAME}$names[$i], ${VARNAME}paths + $path_idx[$i], ${PREFIX}$rules[$i][1] },\n";
        } else {
            print $output "    { NULL, NULL },\n";
        }
    }
    print $output "};\n\n";

    print $output <<"COMMENT";
/* Each table item consists of 7 integers:
 * 0..3 -> lookup key (nodenr, ruleset_1, ruleset_2)
 * 4    -> next state
 * 5..7 -> optimum rule selection (node, child_1, child_2)
 *
 * To improve alignment, we use 8 integers */
COMMENT


    print $output "static MVMint32 ".$VARNAME."states[][8] = {\n";
    for my $expr_op (@expr_ops) {
        my $name = lc $expr_op;
        my $c1 = $table{$name};  # optimum table
        my $s1 = $states{$name}; # state transition table
        next unless defined $c1 && defined $s1;
        if (ref $s1 eq 'HASH') {
            for my $rs1 (sortn keys %$s1) {
                my $s2 = $s1->{$rs1};
                my $c2 = $c1->{$rs1};
                if (ref $s2 eq 'HASH') {
                    for my $rs2 (sortn keys %$s2) {
                        print $output "    { $PREFIX$expr_op, $rs1, $rs2, $s2->{$rs2}, $c2->{$rs2}[0], $c2->{$rs2}[1], $c2->{$rs2}[2] },\n";
                    }
                } else {
                    print $output "    { $PREFIX$expr_op, $rs1, -1, $s2, $c2->[0], $c2->[1], -1 },\n";
                }
            }
        } else {
            print $output "    { $PREFIX$expr_op, -1, -1, $s1, $c1->[0], -1, -1 },\n";
        }
    }
    print $output "};\n\n";
    print $output <<"LOOKUP";
static MVMint32 ${VARNAME}states_lookup(MVMThreadContext *tc, MVMint32 node, MVMint32 c1, MVMint32 c2) {
    MVMint32 top    = (sizeof(${VARNAME}states)/sizeof(${VARNAME}states[0]));
    MVMint32 bottom = 0;
    MVMint32 mid = (top + bottom) / 2;
    while (bottom < mid) {
        if (${VARNAME}states[mid][0] < node) {
            bottom = mid;
            mid    = (top + bottom) / 2;
        } else if (${VARNAME}states[mid][0] > node) {
            top = mid;
            mid = (top + bottom) / 2;
        } else if (${VARNAME}states[mid][1] < c1) {
            bottom = mid;
            mid    = (top + bottom) / 2;
        } else if (${VARNAME}states[mid][1] > c1) {
            top = mid;
            mid = (top + bottom) / 2;
        } else if (${VARNAME}states[mid][2] < c2) {
            bottom = mid;
            mid    = (top + bottom) / 2;
        } else if (${VARNAME}states[mid][2] > c2) {
            top = mid;
            mid = (top + bottom) / 2;
        } else {
            break;
        }
    }
    if (${VARNAME}states[mid][0] != node ||
        ${VARNAME}states[mid][1] != c1   ||
        ${VARNAME}states[mid][2] != c2)
        return -1;
    return mid;
}
LOOKUP
    close $output;
}

__DATA__
# Minimal grammar to test tiler table generator
(tile: a (stack) reg 1)
(tile: b (addr reg) mem 1)
(tile: c (addr reg) reg 2)
(tile: d (const) reg 2)
(tile: e (load reg) reg 5)
(tile: f (load mem) reg 5)
(tile: g (add reg reg) reg 2)
(tile: h (add reg (const)) reg 3)
(tile: i (add reg (load reg)) reg 6)
(tile: j (add reg (load mem)) reg 6)
