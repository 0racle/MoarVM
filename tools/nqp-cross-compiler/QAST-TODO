What next?
DONE * Turn qast.t into an actual test harness thingy
DONE * Implement QAST::SVal and QAST::NVal compilation (should be easy)
DONE * Add tests for this
DONE * Get MoarVM op argument type information generated into lib/MAST/Ops.nqp;
DONE   we'll also need whether the operands are read or written
DONE * Get compile_mastop to check argument types (later we'll do coerce stuff)
DONE * Get compile_mastop to handle instructions that return a result
DONE * Write various tests to exercise QAST::VM

Note that the QAST::VM.new(moarop => '...', ...) handling will lie at the
base of compiling many things in QAST::Op.

16:59 <jnthn> * QAST::Op with :op('bind') (see NQP's QAST::Compiler for inspiration - it doesn't actually
              emit the binding code, but delegates that to the QAST::Var handling code)
16:59 <jnthn> * QAST::Var with :scope('local')
17:00 <jnthn> * QAST::Var with :scope('local') and :decl('var')
17:01 <jnthn> * QAST::Op with :op('if') and :op('unless') - look at the type involved to know whether to
              emit a if_i, if_n, etc. if_o won't work yet.
17:01 <jnthn> Remember that if and unless work as expressions too
17:05 <jnthn> If all that isn't enough then look at getting the nqp op to moar op mapping infrastructure
              set up (a bit like the stuff in QAST::Operations that maps nqp ops to pirops). Note we don't
              need the signature bit, since we have all that information available already. Only thing
              we'll need is an optional "what arg to use as the result" for void ops that should evaluate
              to one of the args.