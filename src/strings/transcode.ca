
/* Transcodes a section of a vector of codepoints or bytes (string
 * MVMString, integer buffer MVMArray (with arbitrary byte width),
 * or socket/filehandle MVMOSHandle), interpreting them as one
 * encoding, transforming them to another. If the source is a
 * (readable) MVMOSHandle, the specified length of items is read
 * from offset. If the dest is concrete, then it must be an MVMArray
 * (writable, not treated as immutable by the HLL), or a writable
 * MVMOSHandle. If it's an array, the output codepoints or bytes are
 * written starting at the specified offset. If it's an MVMOSHandle,
 * the right thing is done depending whether it's a socket or 
 * filehandle (the offset might be relevant, and flags might be
 * passed). If dest is not concrete, then it is a type object, either
 * MVMString or MVMArray. A new object will be allocated of that type
 * and the codepoints or bytes are written into its storage. The
 * inbound Unicode normalization level is arbitrary; it is what it
 * is. A destination normalization level parameter is currently
 * passed, but soon it will get its value from a HLL config global.
 * If length is -1, it means "to the end" of the (socket, filehandle,
 * array, or string). */
MVMObject * MVM_transcode(MVMThreadContext *tc,
        MVMObject *src, MVMint64 src_enc, MVMint64 src_offset,
            MVMint64 length, MVMint64 src_flags,
        MVMObject *dest, MVMint64 dest_enc, MVMint64 dest_offset,
            MVMint64 dest_flags, MVMint64 dest_norm) {
    MVMint32 read_code, decode_code, normalize_code,
            encode_code, write_code;
    void * read_state, decode_state, normalize_state,
            encode_state, write_state;
    MVMuint32 src_repr_id, dest_repr_id;
    
    /* some sanity assertions and determine codes for entering the
     * specialized branches. */
    
    /* validate source */
    if (!src)
        MVM_exception_throw_adhoc(tc, "transcode source was null");
    if (!IS_CONCRETE(src))
        MVM_exception_throw_adhoc(tc, "transcode source was not a concrete object");
    src_repr_id = REPR(oshandle)->ID;
    if (       src_repr_id != MVM_REPR_ID_MVMOSHandle
            && src_repr_id != MVM_REPR_ID_MVMString
            && src_repr_id != MVM_REPR_ID_MVMArray)
            MVM_exception_throw_adhoc(tc, "transcode source must be a "
                "string, array, filehandle, or socket.");
    
    /* validate destination */
    if (!dest && !(dest_flags > 0 && dest_flags < 9))
        MVM_exception_throw_adhoc(tc, "transcode destination was null");
    /* XXX if dest is null && flags signifies to use a default type,
     * use it. 1 is stdout, 2 is stderr, 3 is string, 4 is byte
     * array, 5 is int16 array, 6 is int32 array, 7 is int64 array,
     * 8 is object array (for reading a dirhandle). */
    dest_repr_id = REPR(oshandle)->ID;
    if (IS_CONCRETE(dest)) {
        if (       dest_repr_id != MVM_REPR_ID_MVMOSHandle
                && dest_repr_id != MVM_REPR_ID_MVMArray)
            MVM_exception_throw_adhoc(tc, "transcode destination must be an "
                "array, filehandle, or socket.");
    }
    else if (  dest_repr_id != MVM_REPR_ID_MVMString
            && dest_repr_id != MVM_REPR_ID_MVMArray)
        MVM_exception_throw_adhoc(tc, "transcode destination type object must be a "
            "string or array type.");
    
    /* determine read_code */
    switch (src_repr_id) {
        case MVM_REPR_ID_MVMOSHandle: {
            MVMuint32 handle_type = MVM_OSHANDLE_TYPE(src);
            switch (handle_type) {
                case MVM_OSHANDLE_TYPE_UNINIT:
                    MVM_exception_throw_adhoc(tc,
                        "transcode source handle is uninitialized");
                    break;
                case MVM_OSHANDLE_TYPE_FILE:
                    read_code = 1;
                    break;
                case MVM_OSHANDLE_TYPE_DIR:
                    read_code = 2;
                    break;
                case MVM_OSHANDLE_TYPE_SOCKET:
                    read_code = 3;
                    break;
                default:
                    MVM_exception_throw_adhoc(tc, /* XXX panic instead? */
                        "transcode unhandled MVMOSHandle type");
            }
            break;
        }
        case MVM_REPR_ID_MVMString:
            read_code = 4;
            break;
        case MVM_REPR_ID_MVMArray: {
        /* XXX determine bit width and specialize further.
         * Assume 32-bit integers for now
            MVMuint32 width = 
            */
            read_code = 5;
        }
    }
    
    /* XXX validate src_enc */
    decode_code = (MVMuint32)src_enc;
    
    /* XXX validate dest_norm */
    normalize_code = (MVMuint32)dest_norm;
    
    /* XXX validate dest_enc */
    encode_code = (MVMuint32)dest_enc;
    
    /* determine write_code */
    switch (dest_repr_id) {
        case MVM_REPR_ID_MVMOSHandle: {
            MVMuint32 handle_type = MVM_OSHANDLE_TYPE(dest);
            switch (handle_type) {
                case MVM_OSHANDLE_TYPE_UNINIT:
                    MVM_exception_throw_adhoc(tc, /* shouldn't reach this */
                        "transcode destination handle is uninitialized");
                    break;
                case MVM_OSHANDLE_TYPE_FILE:
                    write_code = 1;
                    break;
                case MVM_OSHANDLE_TYPE_DIR:
                    MVM_exception_throw_adhoc(tc,
                        "transcode destination cannot be a dirhandle");
                    break;
                case MVM_OSHANDLE_TYPE_SOCKET:
                    write_code = 3;
                    break;
                default:
                    MVM_exception_throw_adhoc(tc,
                        "transcode unhandled MVMOSHandle type");
            }
            break;
        }
        case MVM_REPR_ID_MVMString:
            read_code = 4;
            break;
        case MVM_REPR_ID_MVMArray: {
        /* XXX determine bit width and specialize further.
         * Assume 32-bit integers for now
            MVMuint32 width = 
            */
            read_code = 5;
        }
    }
    
}
