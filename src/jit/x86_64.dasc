#include "moar.h"
#include <dasm_proto.h>
#include <dasm_x86.h>
#include "emit.h"

|.arch x64
|.actionlist actions
|.section code
|.globals JIT_LABEL_

const unsigned char * MVM_jit_actions(void) {
    return actions;
}

const unsigned int MVM_jit_num_globals(void) {
    return JIT_LABEL__MAX;
}

#define JIT_FRAME_SIZE 16

/* Type maps for work and frame registers. This is fragile. */
|.type WORK, MVMRegister, r15
|.type FRAME, MVMFrame, r14

|.macro addarg, i, val
||switch(i) {
||    case 0:
|         mov rdi, val
||        break;
||    case 1:
|         mov rsi, val
||        break;
||    case 2:
|         mov rdx, val
||        break;
||    case 3:
|         mov rcx, val
||        break;
||    case 4:
|         mov r8, val
||        break;
||    case 5:
|         mov r9, val
||        break;
||    default:
||        MVM_exception_throw_adhoc(tc, "Can't JIT more than 6 arguments");
||}
|.endmacro



|.macro setup, loc
| mov FRAME, loc
| mov WORK, FRAME->work
|.endmacro



/* A function prologue is always the same in x86 / x64, becuase
 * we do not provide variable arguments, instead arguments are provided
 * via a frame. All JIT entry points receive prologue */
void MVM_jit_emit_prologue(MVMThreadContext *tc, dasm_State **Dst) {
    /* set up our C call frame, i.e. allocate stack space*/
    | push rbp
    | mov rbp, rsp
    | sub rsp, JIT_FRAME_SIZE

    | mov [rbp-8], rdi              // thread context
    | mov [rbp-16], rsi             // mvm frame
    | setup rsi                     // setup our work registers

}

/* And a function epilogue is also always the same */
void MVM_jit_emit_epilogue(MVMThreadContext *tc, dasm_State **Dst) {
    | ->exit:
    | mov rsp, rbp
    | pop rbp
    | ret
}

/* compile per instruction, can't really do any better yet */
void MVM_jit_emit_primitive(MVMThreadContext *tc, MVMJitPrimitive * prim,
                            dasm_State **Dst) {
    MVMSpeshIns *ins = prim->ins;
    fprintf(stderr, "original opcode: <%s>\n", ins->info->name);
    switch (ins->info->opcode) {
    case MVM_OP_const_i64_16: {
        MVMint32 reg = ins->operands[0].reg.orig;
        /* Upgrade to 64 bit */
        MVMint64 val = (MVMint64)ins->operands[1].lit_i16;
        fprintf(stderr, "Emit store %d reg %d\n", val, reg);
        | mov WORK[reg], qword val
        break;
    }
    case MVM_OP_const_i64: {
        MVMint32 reg = ins->operands[0].reg.orig;
        MVMint64 val = ins->operands[1].lit_i64;
        | mov WORK[reg], qword val
        break;
    }
    case MVM_OP_const_s: {
         MVMint32 reg = ins->operands[0].reg.i;
         MVMint32 idx = ins->operands[1].lit_str_idx;
         break;
    }
    case MVM_OP_add_i: {
        /* a = b + c */
        MVMint32 reg_a = ins->operands[0].reg.orig;
        MVMint32 reg_b = ins->operands[1].reg.orig;
        MVMint32 reg_c = ins->operands[2].reg.orig;
        fprintf(stderr, "Emit add r%d = r%d  + r%d\n", reg_a, reg_b, reg_c);
        | mov rax, WORK[reg_b]
        | add rax, WORK[reg_c]
        | mov WORK[reg_a], rax
        break;
    }
    default:
        MVM_exception_throw_adhoc(tc, "Can't JIT opcode");
    }
}

void MVM_jit_emit_call_c(MVMThreadContext *tc, MVMJitCallC * call_spec,
                         dasm_State **Dst) {
    int i;
    MVMJitCallArg *args = call_spec->args;
    fprintf(stderr, "Emitting c call\n");
    if (call_spec->has_vargs) {
        MVM_exception_throw_adhoc(tc, "JIT can't handle varargs yet");
    }
    /* first, add arguments */
    for (i = 0; i < call_spec->num_args; i++) {
        switch (args[i].base) {
        case MVM_JIT_ARG_STACK:
            fprintf(stderr, "Emit load stack offset arg %d\n", args[i].offset);
            | addarg i, [rbp-args[i].offset]
            break;
        case MVM_JIT_ARG_REG:
            fprintf(stderr, "Emit work offset arg %d\n", args[i].offset);
            | addarg i, WORK[args[i].offset]
            break;
        case MVM_JIT_ARG_CONST:
            fprintf(stderr, "Emit constant arg %d\n", args[i].offset);
            | addarg i, args[i].offset
            break;
        }
    }
    | mov64 r10, (uintptr_t)call_spec->func_ptr
    | call r10
    /* Restore the work register pointer */
    | setup [rbp-16]
}

void MVM_jit_emit_branch(MVMThreadContext *tc, MVMJitBranch * branch,
                         dasm_State **Dst) {
    if (branch->destination == MVM_JIT_BRANCH_EXIT) {
        | jmp ->exit
    } else {
        | jmp =>(branch->destination)
    }
    /* This fixes an issue with aligning the labels. */
    | nop
}

void MVM_jit_emit_label(MVMThreadContext *tc, MVMint32 label,
                        dasm_State **Dst) {
    | =>(label):
}