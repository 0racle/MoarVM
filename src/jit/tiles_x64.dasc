#include "x64_tile_decl.h"


/* register classes */
#define MVM_JIT_X64_GPR 0
#define MVM_JIT_X64_SSE 1

/* stub register allocator */
MVMint8 MVM_jit_register_allocate(MVMThreadContext *tc, MVMJitCompiler *compiler, MVMint32 cls) {
    return -1;
}

void MVM_jit_register_free(MVMThreadContext *tc, MVMJitCompiler *compiler, MVMint32 cls, MVMint8 num) {
}


#define X64_GPR(_) \
    _(RAX), \
    _(RCX), \
    _(RDX), \
    _(RBX), \
    _(RSP), \
    _(RBP), \
    _(RSI), \
    _(RDI), \
    _(R8), \
    _(R9), \
    _(R10), \
    _(R11), \
    _(R12), \
    _(R13), \
    _(R14), \
    _(R15)

enum {
#define GPRNAME(x) MVM_JIT_X64_ ## x
X64_GPR(GPRNAME)
#undef GPRNAME
};


MVM_JIT_TILE_DECL(load_stack) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_RSP;
}

MVM_JIT_TILE_DECL(load_local) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_RBX;
}

MVM_JIT_TILE_DECL(load_frame) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_R12;
}

MVM_JIT_TILE_DECL(load_cu) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_R13;
}

MVM_JIT_TILE_DECL(load_tc) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_R14;
}

MVM_JIT_TILE_DECL(addr_mem) {
    values[0]->u.mem.r0 = values[1]->u.reg.num;
    values[0]->u.mem.r1 = -1;
    values[0]->u.mem.c   = args[0];
}

MVM_JIT_TILE_DECL(addr_reg) {
    MVMint8 out  = values[0]->u.reg.num;
    MVMint8 base = values[1]->u.reg.num;
    MVMint32 ofs = args[0];
    | lea Rq(out), [Rq(base)+ofs];
}

MVM_JIT_TILE_DECL(idx_mem) {
    values[0]->u.mem.r0 = values[1]->u.reg.num;
    values[0]->u.mem.r1 = values[2]->u.reg.num;
    values[0]->u.mem.c  = args[0];
}

MVM_JIT_TILE_DECL(idx_reg) {
    MVMint8 out  = values[0]->u.reg.num;
    MVMint8 base = values[1]->u.reg.num;
    MVMint8 idx  = values[2]->u.reg.num;
    MVMint8 scl  = args[0];
    if (scl != 8) {
        | lea Rq(out), [Rq(base)+Rq(idx)*8];
    } else {
        MVM_oops(tc, "Scales other than 8 NYI\n");
    }
}


MVM_JIT_TILE_DECL(const_reg) {
    MVMint8 out = values[0]->u.reg.num;
    if (args[1] == 8 && !fits_in_32_bit(args[0])) {
        | mov64 Rq(out), args[0];
    } else {
        | mov Rq(out), args[0];
    }
}



MVM_JIT_TILE_DECL(load_reg) {
    MVMint8 out  = values[0]->u.reg.num;
    MVMint8 base = values[1]->u.reg.num;
    switch (args[0]) {
    case 1:
        | mov Rb(out), [Rq(base)];
        break;
    case 2:
        | mov Rw(out), [Rq(base)];
        break;
    case 4:
        | mov Rd(out), [Rq(base)];
        break;
    case 8:
        | mov Rq(out), [Rq(base)];
        break;
    default:
        MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
    }
}

MVM_JIT_TILE_DECL(load_mem) {
    MVMint8 out  = values[0]->u.reg.num;
    if (values[1]->u.mem.r1 < 0) {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 ofs  = values[1]->u.mem.c;
        switch (args[0]) {
        case 1:
            | mov Rb(out), [Rq(base)+ofs];
            break;
        case 2:
            | mov Rw(out), [Rq(base)+ofs];
            break;
        case 4:
            | mov Rd(out), [Rq(base)+ofs];
            break;
        case 8:
            | mov Rq(out), [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
        }
    } else {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 idx  = values[1]->u.mem.r1;
        MVMint8 scl  = values[1]->u.mem.c;
        if (scl != 8) {
            MVM_oops(tc, "Unsupported scale size: %d\n", scl);
        }
        switch (args[0]) {
        case 1:
            | mov Rb(out), [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | mov Rw(out), [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | mov Rd(out), [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | mov Rq(out), [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
        }
    }
}

MVM_JIT_TILE_DECL(load_lbl) {
    MVMint8 out    = values[0]->u.reg.num;
    MVMint32 label = values[1]->u.label;
    switch (args[0]) {
    case 1:
        | mov Rb(out), [=>(label)];
        break;
    case 2:
        | mov Rw(out), [=>(label)];
        break;
    case 4:
        | mov Rd(out), [=>(label)];
        break;
    case 8:
        | mov Rq(out), [=>(label)];
        break;
    default:
        MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
    }
}

MVM_JIT_TILE_DECL(store_reg) {
    MVMint8 base = values[1]->u.reg.num;
    MVMint8 value = values[2]->u.reg.num;
    switch (args[0]) {
    case 1:
        | mov byte [Rq(base)], Rb(value);
        break;
    case 2:
        | mov word [Rq(base)], Rw(value);
        break;
    case 4:
        | mov dword [Rq(base)], Rd(value);
        break;
    case 8:
        | mov qword [Rq(base)], Rq(value);
        break;
    default:
        MVM_oops(tc, "Unsupported store size: %d\n", args[0]);
    }
}

MVM_JIT_TILE_DECL(store_mem) {
    if (values[1]->u.mem.r1 < 0) {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 ofs  = values[1]->u.mem.c;
        MVMint8 value = values[2]->u.reg.num;
        switch (args[0]) {
        case 1:
            | mov byte [Rq(base)+ofs], Rb(value);
            break;
        case 2:
            | mov word [Rq(base)+ofs], Rw(value);
            break;
        case 4:
            | mov dword [Rq(base)+ofs], Rd(value);
            break;
        case 8:
            | mov qword [Rq(base)+ofs], Rq(value);
            break;
        default:
            MVM_oops(tc, "Unsupported store size: %d\n", args[0]);
        }
    } else {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 idx  = values[1]->u.mem.r1;
        MVMint8 scl  = values[1]->u.mem.c;
        MVMint8 value = values[2]->u.reg.num;
        if (scl != 8)
            MVM_oops(tc, "Scale %d NYI\n", scl);
        switch (args[0]) {
        case 1:
            | mov byte [Rq(base)+Rq(idx)*8], Rb(value);
            break;
        case 2:
            | mov word [Rq(base)+Rq(idx)*8], Rw(value);
            break;
        case 4:
            | mov dword [Rq(base)+Rq(idx)*8], Rd(value);
            break;
        case 8:
            | mov qword [Rq(base)+Rq(idx)*8], Rq(value);
            break;
        default:
            MVM_oops(tc, "Unsupported store size: %d\n", args[0]);
        }
    }
}

MVM_JIT_TILE_DECL(add_reg) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint8 in2  = values[2]->u.reg.num;
    if (out == in2) {
        | add Rq(out), Rq(in2);
    } else {
        | mov Rq(out), Rq(in1);
        | add Rq(out), Rq(in2);
    }
}

MVM_JIT_TILE_DECL(add_const) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint64 val = values[2]->u.const_val; // or tree->nodes[tree->nodes
    if (out == in1) {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            MVMint8 tmp = MVM_jit_register_allocate(tc, compiler, MVM_JIT_X64_GPR);
            | mov64 Rq(tmp), val;
            | add Rq(in1), Rq(tmp);
            MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
        } else {
            | add Rq(in1), val;
        }
    } else {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            | mov64 Rq(out), val;
            | add Rq(out), Rq(in1);
        } else {
            | mov Rq(out), Rq(in1);
            | add Rq(out), val;
        }
    }
}

MVM_JIT_TILE_DECL(add_load_mem) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1 = values[1]->u.reg.num;
    MVMint8 base = values[2]->u.mem.r0;
    if (in1 != out) {
        | mov Rq(out), in1;
    }
    if (values[2]->u.mem.r1 < 0) {
        MVMint32 ofs = values[2]->u.mem.c;
        switch (values[2]->size) {
        case 1:
            | add Rb(out), byte [Rq(base)+ofs];
            break;
        case 2:
            | add Rw(out), word [Rq(base)+ofs];
            break;
        case 4:
            | add Rd(out), dword [Rq(base)+ofs];
            break;
        case 8:
            | add Rq(out), qword [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    } else {
        MVMint8  idx = values[2]->u.mem.r1;
        MVMint32 scl = values[2]->u.mem.c;
        if (scl != 8)
            MVM_oops(tc, "IDX Scale %d NYI\n", scl);
        switch (values[2]->size) {
        case 1:
            | add Rb(out), byte [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | add Rw(out), word [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | add Rd(out), dword [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | add Rq(out), qword [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    }

}


MVM_JIT_TILE_DECL(sub_reg) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint8 in2  = values[2]->u.reg.num;
    if (out == in2) {
        | sub Rq(out), Rq(in2);
    } else {
        | mov Rq(out), Rq(in1);
        | sub Rq(out), Rq(in2);
    }
}

MVM_JIT_TILE_DECL(sub_const) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint64 val = values[2]->u.const_val; // or tree->nodes[tree->nodes
    if (out == in1) {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            MVMint8 tmp = MVM_jit_register_allocate(tc, compiler, MVM_JIT_X64_GPR);
            | mov64 Rq(tmp), val;
            | sub Rq(in1), Rq(tmp);
            MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
        } else {
            | sub Rq(in1), val;
        }
    } else {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            | mov64 Rq(out), val;
            | sub Rq(out), Rq(in1);
        } else {
            | mov Rq(out), Rq(in1);
            | sub Rq(out), val;
        }
    }
}

MVM_JIT_TILE_DECL(sub_load_mem) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1 = values[1]->u.reg.num;
    MVMint8 base = values[2]->u.mem.r0;
    if (in1 != out) {
        | mov Rq(out), in1;
    }
    if (values[2]->u.mem.r1 < 0) {
        MVMint32 ofs = values[2]->u.mem.c;
        switch (values[2]->size) {
        case 1:
            | sub Rb(out), byte [Rq(base)+ofs];
            break;
        case 2:
            | sub Rw(out), word [Rq(base)+ofs];
            break;
        case 4:
            | sub Rd(out), dword [Rq(base)+ofs];
            break;
        case 8:
            | sub Rq(out), qword [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    } else {
        MVMint8  idx = values[2]->u.mem.r1;
        MVMint32 scl = values[2]->u.mem.c;
        if (scl != 8)
            MVM_oops(tc, "IDX Scale %d NYI\n", scl);
        switch (values[2]->size) {
        case 1:
            | sub Rb(out), byte [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | sub Rw(out), word [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | sub Rd(out), dword [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | sub Rq(out), qword [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    }
}


MVM_JIT_TILE_DECL(and_reg) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint8 in2  = values[2]->u.reg.num;
    if (out == in2) {
        | and Rq(out), Rq(in2);
    } else {
        | mov Rq(out), Rq(in1);
        | and Rq(out), Rq(in2);
    }
}

MVM_JIT_TILE_DECL(and_const) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint64 val = values[2]->u.const_val; // or tree->nodes[tree->nodes
    if (out == in1) {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            MVMint8 tmp = MVM_jit_register_allocate(tc, compiler, MVM_JIT_X64_GPR);
            | mov64 Rq(tmp), val;
            | and Rq(in1), Rq(tmp);
            MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
        } else {
            | and Rq(in1), val;
        }
    } else {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            | mov64 Rq(out), val;
            | and Rq(out), Rq(in1);
        } else {
            | mov Rq(out), Rq(in1);
            | and Rq(out), val;
        }
    }
}

MVM_JIT_TILE_DECL(and_load_mem) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1 = values[1]->u.reg.num;
    MVMint8 base = values[2]->u.mem.r0;
    if (in1 != out) {
        | mov Rq(out), in1;
    }
    if (values[2]->u.mem.r1 < 0) {
        MVMint32 ofs = values[2]->u.mem.c;
        switch (values[2]->size) {
        case 1:
            | and Rb(out), byte [Rq(base)+ofs];
            break;
        case 2:
            | and Rw(out), word [Rq(base)+ofs];
            break;
        case 4:
            | and Rd(out), dword [Rq(base)+ofs];
            break;
        case 8:
            | and Rq(out), qword [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    } else {
        MVMint8  idx = values[2]->u.mem.r1;
        MVMint32 scl = values[2]->u.mem.c;
        if (scl != 8)
            MVM_oops(tc, "IDX Scale %d NYI\n", scl);
        switch (values[2]->size) {
        case 1:
            | and Rb(out), byte [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | and Rw(out), word [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | and Rd(out), dword [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | and Rq(out), qword [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    }
}


MVM_JIT_TILE_DECL(nz_reg) {
    MVMint8 reg = values[1]->u.reg.num;
    | test Rq(reg), Rq(reg);
}


MVM_JIT_TILE_DECL(nz_mem) {

}

MVM_JIT_TILE_DECL(nz_and) {

}
