#include "moar.h"
#include <dasm_proto.h>
#include <dasm_x86.h>
#include "emit.h"

|.arch x64
|.actionlist actions
|.section code
|.globals JIT_LABEL_

/* Static allocation of relevant types to registers. I pick
 * callee-save registers for efficiency. It is likely we'll be calling
 * quite a C functions, and this saves us the trouble of storing
 * them. Moreover, C compilers preferentially do not use callee-saved
 * registers, and so in most cases, these won't be touched at all. */
|.type TC, MVMThreadContext, r14
|.type FRAME, MVMFrame
|.type ARGCTX, MVMArgProcContext
/* 'alternative base pointer. I'll be using this often, so picking rbx
 * here rather than the extended registers will likely lead to smaller
 * bytecode */
|.type WORK, MVMRegister, rbx
|.type ARGS, MVMRegister, r12
|.type ENV,  MVMRegister, r13

|.macro saveregs
| push TC; push WORK; push ARGS; push ENV
|.endmacro

|.macro restoreregs
| pop ENV; pop ARGS; pop WORK; pop TC
|.endmacro


const MVMint32 MVM_jit_support(void) {
    return 1;
}

const unsigned char * MVM_jit_actions(void) {
    return actions;
}

const unsigned int MVM_jit_num_globals(void) {
    return JIT_LABEL__MAX;
}


/* C Call argument registers */
|.if WIN32
|.define ARG1, rcx
|.define ARG2, rdx
|.define ARG3, r8
|.define ARG4, r9
|.else
|.define ARG1, rdi
|.define ARG2, rsi
|.define ARG3, rdx
|.define ARG4, rcx
|.define ARG5, r8
|.define ARG6, r9
|.endif

/* Special register for the function to be invoked */
|.define FUNCTION, r10;
/* all-purpose temporary register */
|.define TMP, r11;
/* return value */
|.define RV, rax


|.macro callp, funcptr
| mov64 FUNCTION, (uintptr_t)funcptr
|.if WIN32
| sub rsp, 32
| call FUNCTION
| add rsp, 32
|.else
| call FUNCTION
|.endif
|.endmacro

|.macro addarg, i, val
||switch(i) {
||    case 0:
|         mov ARG1, val
||        break;
||    case 1:
|         mov ARG2, val
||        break;
||    case 2:
|         mov ARG3, val
||        break;
||    case 3:
|         mov ARG4, val
||        break;
|.if not WIN32
||    case 4:
|         mov ARG5, val
||        break;
||    case 5:
|         mov ARG6, val
||        break;
|.endif
||    default:
||        MVM_exception_throw_adhoc(tc, "Can't JIT more than %d arguments", i);
||}
|.endmacro


/* A function prologue is always the same in x86 / x64, becuase
 * we do not provide variable arguments, instead arguments are provided
 * via a frame. All JIT entry points receive a prologue. */
void MVM_jit_emit_prologue(MVMThreadContext *tc, MVMJitGraph *jg,
                           dasm_State **Dst) {
    /* Setup stack */
    | push rbp
    | mov rbp, rsp
    /* save callee-save registers */
    | saveregs
    /* setup special frame variables */
    | mov TC,   ARG1
    | mov WORK, FRAME:ARG2->work
    | mov ARGS, FRAME:ARG2->params.args
    | mov ENV,  FRAME:ARG2->env
}

/* And a function epilogue is also always the same */
void MVM_jit_emit_epilogue(MVMThreadContext *tc, MVMJitGraph *jg,
                           dasm_State **Dst) {
    | ->exit:
    /* restore callee-save registers */
    | restoreregs
    /* Restore stack */
    | mov rsp, rbp
    | pop rbp
    | ret
}

/* compile per instruction, can't really do any better yet */
void MVM_jit_emit_primitive(MVMThreadContext *tc, MVMJitGraph *jg,
                            MVMJitPrimitive * prim, dasm_State **Dst) {
    MVMSpeshIns *ins = prim->ins;
    MVM_jit_log(tc, "emit opcode: <%s>\n", ins->info->name);
    /* Quite a few of these opcodes are copies. Ultimately, I want to
     * move copies to their own node (MVMJitCopy or such), and reduce
     * the number of copies (and thereby increase the efficiency), but
     * currently that isn't really feasible. */
    switch (ins->info->opcode) {
    case MVM_OP_const_i64_16: {
        MVMint32 reg = ins->operands[0].reg.orig;
        /* Upgrade to 64 bit */
        MVMint64 val = (MVMint64)ins->operands[1].lit_i16;
        | mov WORK[reg], qword val
        break;
    }
    case MVM_OP_const_i64: {
        MVMint32 reg = ins->operands[0].reg.orig;
        MVMint64 val = ins->operands[1].lit_i64;
        | mov64 TMP, val
        | mov WORK[reg], TMP
        break;
    }
    case MVM_OP_sp_getarg_o:
    case MVM_OP_sp_getarg_n:
    case MVM_OP_sp_getarg_s:
    case MVM_OP_sp_getarg_i: {
        MVMint32 reg = ins->operands[0].reg.orig;
        MVMuint16 idx = ins->operands[1].callsite_idx;
        | mov TMP, ARGS[idx]
        | mov WORK[reg], TMP
        break;
    }
    case MVM_OP_set: {
         MVMint32 reg1 = ins->operands[0].reg.orig;
         MVMint32 reg2 = ins->operands[1].reg.orig;
         | mov TMP, WORK[reg2]
         | mov WORK[reg1], TMP
         break;
    }
    case MVM_OP_const_s: {
         MVMint32 reg = ins->operands[0].reg.orig;
         MVMint32 idx = ins->operands[1].lit_str_idx;
         MVMStaticFrame *sf = jg->spesh->sf;
         MVMString * s = sf->body.cu->body.strings[idx];
         // TODO fixme
         | mov64 TMP, (uintptr_t)s
         | mov WORK[reg], TMP
         break;
    }
    case MVM_OP_add_i: {
        /* a = b + c */
        MVMint32 reg_a = ins->operands[0].reg.orig;
        MVMint32 reg_b = ins->operands[1].reg.orig;
        MVMint32 reg_c = ins->operands[2].reg.orig;
        | mov rax, WORK[reg_b]
        | add rax, WORK[reg_c]
        | mov WORK[reg_a], rax
        break;
    }
    case MVM_OP_sub_i: {
        MVMint32 reg_a = ins->operands[0].reg.orig;
        MVMint32 reg_b = ins->operands[1].reg.orig;
        MVMint32 reg_c = ins->operands[2].reg.orig;
        | mov rax, WORK[reg_b]
        | sub rax, WORK[reg_c]
        | mov WORK[reg_a], rax
        break;
    }
    case MVM_OP_inc_i: {
         MVMint32 reg = ins->operands[0].reg.orig;
         | inc qword WORK[reg]
         break;
    }
    case MVM_OP_dec_i: {
        MVMint32 reg = ins->operands[0].reg.orig;
        | dec qword WORK[reg]
        break;
    }
    case MVM_OP_eq_i:
    case MVM_OP_ne_i:
    case MVM_OP_lt_i:
    case MVM_OP_le_i:
    case MVM_OP_gt_i:
    case MVM_OP_ge_i: {
        MVMint32 reg_a = ins->operands[0].reg.orig;
        MVMint32 reg_b = ins->operands[1].reg.orig;
        MVMint32 reg_c = ins->operands[2].reg.orig;
        | mov rax, WORK[reg_b]
        | cmp rax, WORK[reg_c]
        /* copy the right comparison bit */
        switch(ins->info->opcode) {
        case MVM_OP_eq_i:
            | sete al
            break;
        case MVM_OP_ne_i:
            | setne al
            break;
        case MVM_OP_lt_i:
            | setl al
            break;
        case MVM_OP_le_i:
            | setle al
            break;
        case MVM_OP_gt_i:
            | setg al
            break;
        case MVM_OP_ge_i:
            | setge al
            break;
        }
        | movzx rax, al        // zero extend al (byte) to rax (quadword)
        | mov WORK[reg_a], rax // store in mvm register
        break;
    }
    default:
        MVM_exception_throw_adhoc(tc, "Can't JIT opcode");
    }
}

void MVM_jit_emit_call_c(MVMThreadContext *tc, MVMJitGraph *jg,
                         MVMJitCallC * call_spec, dasm_State **Dst) {
    int i;
    MVMJitAddr *args = call_spec->args;
    MVM_jit_log(tc, "emit c call <%d args>\n", call_spec->num_args);
    if (call_spec->has_vargs) {
        MVM_exception_throw_adhoc(tc, "JIT can't handle varargs yet");
    }
    /* first, add arguments */
    for (i = 0; i < call_spec->num_args; i++) {
        switch (args[i].base) {
        case MVM_JIT_ADDR_STACK: /* unlikely to use this now, though */
            | addarg i, [rbp-args[i].idx];
            break;
        case MVM_JIT_ADDR_INTERP:
            switch (args[i].idx) {
            case MVM_JIT_INTERP_TC:
                | addarg i, TC;
                 break;
            case MVM_JIT_INTERP_FRAME:
                | addarg i, TC->cur_frame;
                break;
            }
            break;
        case MVM_JIT_ADDR_REG:
            | addarg i, WORK[args[i].idx];
            break;
        case MVM_JIT_ADDR_LITERAL:
            | addarg i, args[i].idx;
            break;
        }
    }
    /* Emit the call. I think we should be able to do something smarter than
     * store the constant into the bytecode, like a data segment. But I'm
     * not sure. */
     | callp call_spec->func_ptr
}

void MVM_jit_emit_branch(MVMThreadContext *tc, MVMJitGraph *jg,
                         MVMJitBranch * branch, dasm_State **Dst) {
    MVMSpeshIns *ins = branch->ins;
    MVMint32 name = branch->dest.name;
    if (ins == NULL || ins->info->opcode == MVM_OP_goto) {
        MVM_jit_log(tc, "emit jump to label %d\n", name);
        if (name == MVM_JIT_BRANCH_EXIT) {
            | jmp ->exit
        } else {
            | jmp =>(name)
        }
    } else {
        MVMint16 reg = ins->operands[0].reg.orig;
        MVM_jit_log(tc, "emit branch <%s> to label %d\n",
                    ins->info->name, name);
        switch(ins->info->opcode) {
        case MVM_OP_if_i:
            | mov rax, WORK[reg];
            | test rax, rax;
            | jnz =>(name); // jump to dynamic label
            break;
        case MVM_OP_unless_i:
            | mov rax, WORK[reg];
            | test rax, rax;
            | jz =>(name);
            break;
        default:
            MVM_exception_throw_adhoc(tc, "JIT: Can't handle conditional <%s>",
                                      ins->info->name);
        }
    }
}

void MVM_jit_emit_label(MVMThreadContext *tc, MVMJitGraph *jg,
                        MVMJitLabel *label, dasm_State **Dst) {
    | =>(label->name):
}

void MVM_jit_emit_rvh(MVMThreadContext *tc, MVMJitGraph *jg,
                      MVMJitRVH *rvh, dasm_State **Dst) {
    switch(rvh->mode) {
    case MVM_JIT_RV_VAL_TO_REG:
        | mov WORK[rvh->addr.idx], RV;
        break;
    case MVM_JIT_RV_REF_TO_REG:
        | mov TMP, [RV]; // maybe add an offset?
        | mov WORK[rvh->addr.idx], TMP;
        break;
    case MVM_JIT_RV_REG_TO_PTR:
        | mov TMP, WORK[rvh->addr.idx];
        | mov [RV], TMP;
        break;
    }
}
