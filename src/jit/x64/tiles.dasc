#include "tile_decl.h"


/* register classes */
#define MVM_JIT_X64_GPR 0
#define MVM_JIT_X64_SSE 1




#define X64_GPR(_) \
    _(RAX), \
    _(RCX), \
    _(RDX), \
    _(RBX), \
    _(RSP), \
    _(RBP), \
    _(RSI), \
    _(RDI), \
    _(R8), \
    _(R9), \
    _(R10), \
    _(R11), \
    _(R12), \
    _(R13), \
    _(R14), \
    _(R15)

enum {
#define GPRNAME(x) MVM_JIT_X64_ ## x
X64_GPR(GPRNAME)
#undef GPRNAME
};


MVM_JIT_TILE_DECL(load_stack) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_RSP;
}

MVM_JIT_TILE_DECL(load_local) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_RBX;
}

MVM_JIT_TILE_DECL(load_frame) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_R12;
}

MVM_JIT_TILE_DECL(load_cu) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_R13;
}

MVM_JIT_TILE_DECL(load_tc) {
    values[0]->u.reg.cls = MVM_JIT_X64_GPR;
    values[0]->u.reg.num = MVM_JIT_X64_R14;
}

MVM_JIT_TILE_DECL(addr_mem) {
    values[0]->u.mem.r0 = values[1]->u.reg.num;
    values[0]->u.mem.r1 = -1;
    values[0]->u.mem.c   = args[0];
}

MVM_JIT_TILE_DECL(addr_reg) {
    MVMint8 out  = values[0]->u.reg.num;
    MVMint8 base = values[1]->u.reg.num;
    MVMint32 ofs = args[0];
    | lea Rq(out), [Rq(base)+ofs];
}

MVM_JIT_TILE_DECL(idx_mem) {
    values[0]->u.mem.r0 = values[1]->u.reg.num;
    values[0]->u.mem.r1 = values[2]->u.reg.num;
    values[0]->u.mem.c  = args[0];
}

MVM_JIT_TILE_DECL(idx_reg) {
    MVMint8 out  = values[0]->u.reg.num;
    MVMint8 base = values[1]->u.reg.num;
    MVMint8 idx  = values[2]->u.reg.num;
    MVMint8 scl  = args[0];
    if (scl != 8) {
        | lea Rq(out), [Rq(base)+Rq(idx)*8];
    } else {
        MVM_oops(tc, "Scales other than 8 NYI\n");
    }
}


MVM_JIT_TILE_DECL(const_reg) {
    MVMint8 out = values[0]->u.reg.num;
    if (args[1] == 8 && !fits_in_32_bit(args[0])) {
        | mov64 Rq(out), args[0];
    } else {
        | mov Rq(out), args[0];
    }
}



MVM_JIT_TILE_DECL(load_reg) {
    MVMint8 out  = values[0]->u.reg.num;
    MVMint8 base = values[1]->u.reg.num;
    switch (args[0]) {
    case 1:
        | mov Rb(out), [Rq(base)];
        break;
    case 2:
        | mov Rw(out), [Rq(base)];
        break;
    case 4:
        | mov Rd(out), [Rq(base)];
        break;
    case 8:
        | mov Rq(out), [Rq(base)];
        break;
    default:
        MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
    }
}

MVM_JIT_TILE_DECL(load_mem) {
    MVMint8 out  = values[0]->u.reg.num;
    if (values[1]->u.mem.r1 < 0) {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 ofs  = values[1]->u.mem.c;
        switch (args[0]) {
        case 1:
            | mov Rb(out), [Rq(base)+ofs];
            break;
        case 2:
            | mov Rw(out), [Rq(base)+ofs];
            break;
        case 4:
            | mov Rd(out), [Rq(base)+ofs];
            break;
        case 8:
            | mov Rq(out), [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
        }
    } else {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 idx  = values[1]->u.mem.r1;
        MVMint8 scl  = values[1]->u.mem.c;
        if (scl != 8) {
            MVM_oops(tc, "Unsupported scale size: %d\n", scl);
        }
        switch (args[0]) {
        case 1:
            | mov Rb(out), [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | mov Rw(out), [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | mov Rd(out), [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | mov Rq(out), [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
        }
    }
}

MVM_JIT_TILE_DECL(load_lbl) {
    MVMint8 out    = values[0]->u.reg.num;
    MVMint32 label = values[1]->u.label;
    switch (args[0]) {
    case 1:
        | mov Rb(out), [=>(label)];
        break;
    case 2:
        | mov Rw(out), [=>(label)];
        break;
    case 4:
        | mov Rd(out), [=>(label)];
        break;
    case 8:
        | mov Rq(out), [=>(label)];
        break;
    default:
        MVM_oops(tc, "Unsupported load size: %d\n", args[0]);
    }
}

MVM_JIT_TILE_DECL(store_reg) {
    MVMint8 base = values[1]->u.reg.num;
    MVMint8 value = values[2]->u.reg.num;
    switch (args[0]) {
    case 1:
        | mov byte [Rq(base)], Rb(value);
        break;
    case 2:
        | mov word [Rq(base)], Rw(value);
        break;
    case 4:
        | mov dword [Rq(base)], Rd(value);
        break;
    case 8:
        | mov qword [Rq(base)], Rq(value);
        break;
    default:
        MVM_oops(tc, "Unsupported store size: %d\n", args[0]);
    }
}

MVM_JIT_TILE_DECL(store_mem) {
    if (values[1]->u.mem.r1 < 0) {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 ofs  = values[1]->u.mem.c;
        MVMint8 value = values[2]->u.reg.num;
        switch (args[0]) {
        case 1:
            | mov byte [Rq(base)+ofs], Rb(value);
            break;
        case 2:
            | mov word [Rq(base)+ofs], Rw(value);
            break;
        case 4:
            | mov dword [Rq(base)+ofs], Rd(value);
            break;
        case 8:
            | mov qword [Rq(base)+ofs], Rq(value);
            break;
        default:
            MVM_oops(tc, "Unsupported store size: %d\n", args[0]);
        }
    } else {
        MVMint8 base = values[1]->u.mem.r0;
        MVMint8 idx  = values[1]->u.mem.r1;
        MVMint8 scl  = values[1]->u.mem.c;
        MVMint8 value = values[2]->u.reg.num;
        if (scl != 8)
            MVM_oops(tc, "Scale %d NYI\n", scl);
        switch (args[0]) {
        case 1:
            | mov byte [Rq(base)+Rq(idx)*8], Rb(value);
            break;
        case 2:
            | mov word [Rq(base)+Rq(idx)*8], Rw(value);
            break;
        case 4:
            | mov dword [Rq(base)+Rq(idx)*8], Rd(value);
            break;
        case 8:
            | mov qword [Rq(base)+Rq(idx)*8], Rq(value);
            break;
        default:
            MVM_oops(tc, "Unsupported store size: %d\n", args[0]);
        }
    }
}

MVM_JIT_TILE_DECL(copy) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 val = values[1]->u.reg.num;
    if (out != val) {
        | mov Rq(out), Rq(val);
    }
}

MVM_JIT_TILE_DECL(add_reg) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint8 in2  = values[2]->u.reg.num;
    if (out == in2) {
        | add Rq(out), Rq(in2);
    } else {
        | mov Rq(out), Rq(in1);
        | add Rq(out), Rq(in2);
    }
}

MVM_JIT_TILE_DECL(add_const) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint64 val = values[2]->u.const_val; // or tree->nodes[tree->nodes
    if (out == in1) {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            MVMint8 tmp = MVM_jit_register_alloc(tc, compiler, MVM_JIT_X64_GPR);
            | mov64 Rq(tmp), val;
            | add Rq(in1), Rq(tmp);
            MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
        } else {
            | add Rq(in1), val;
        }
    } else {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            | mov64 Rq(out), val;
            | add Rq(out), Rq(in1);
        } else {
            | mov Rq(out), Rq(in1);
            | add Rq(out), val;
        }
    }
}

MVM_JIT_TILE_DECL(add_load_mem) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1 = values[1]->u.reg.num;
    MVMint8 base = values[2]->u.mem.r0;
    if (in1 != out) {
        | mov Rq(out), in1;
    }
    if (values[2]->u.mem.r1 < 0) {
        MVMint32 ofs = values[2]->u.mem.c;
        switch (values[2]->size) {
        case 1:
            | add Rb(out), byte [Rq(base)+ofs];
            break;
        case 2:
            | add Rw(out), word [Rq(base)+ofs];
            break;
        case 4:
            | add Rd(out), dword [Rq(base)+ofs];
            break;
        case 8:
            | add Rq(out), qword [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    } else {
        MVMint8  idx = values[2]->u.mem.r1;
        MVMint32 scl = values[2]->u.mem.c;
        if (scl != 8)
            MVM_oops(tc, "IDX Scale %d NYI\n", scl);
        switch (values[2]->size) {
        case 1:
            | add Rb(out), byte [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | add Rw(out), word [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | add Rd(out), dword [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | add Rq(out), qword [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    }

}


MVM_JIT_TILE_DECL(sub_reg) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint8 in2  = values[2]->u.reg.num;
    if (out == in2) {
        | sub Rq(out), Rq(in2);
    } else {
        | mov Rq(out), Rq(in1);
        | sub Rq(out), Rq(in2);
    }
}

MVM_JIT_TILE_DECL(sub_const) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint64 val = values[2]->u.const_val; // or tree->nodes[tree->nodes
    if (out == in1) {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            MVMint8 tmp = MVM_jit_register_alloc(tc, compiler, MVM_JIT_X64_GPR);
            | mov64 Rq(tmp), val;
            | sub Rq(in1), Rq(tmp);
            MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
        } else {
            | sub Rq(in1), val;
        }
    } else {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            | mov64 Rq(out), val;
            | sub Rq(out), Rq(in1);
        } else {
            | mov Rq(out), Rq(in1);
            | sub Rq(out), val;
        }
    }
}

MVM_JIT_TILE_DECL(sub_load_mem) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1 = values[1]->u.reg.num;
    MVMint8 base = values[2]->u.mem.r0;
    if (in1 != out) {
        | mov Rq(out), in1;
    }
    if (values[2]->u.mem.r1 < 0) {
        MVMint32 ofs = values[2]->u.mem.c;
        switch (values[2]->size) {
        case 1:
            | sub Rb(out), byte [Rq(base)+ofs];
            break;
        case 2:
            | sub Rw(out), word [Rq(base)+ofs];
            break;
        case 4:
            | sub Rd(out), dword [Rq(base)+ofs];
            break;
        case 8:
            | sub Rq(out), qword [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    } else {
        MVMint8  idx = values[2]->u.mem.r1;
        MVMint32 scl = values[2]->u.mem.c;
        if (scl != 8)
            MVM_oops(tc, "IDX Scale %d NYI\n", scl);
        switch (values[2]->size) {
        case 1:
            | sub Rb(out), byte [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | sub Rw(out), word [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | sub Rd(out), dword [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | sub Rq(out), qword [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    }
}


MVM_JIT_TILE_DECL(and_reg) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint8 in2  = values[2]->u.reg.num;
    if (out == in2) {
        | and Rq(out), Rq(in2);
    } else {
        | mov Rq(out), Rq(in1);
        | and Rq(out), Rq(in2);
    }
}

MVM_JIT_TILE_DECL(and_const) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1  = values[1]->u.reg.num;
    MVMint64 val = values[2]->u.const_val; // or tree->nodes[tree->nodes
    if (out == in1) {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            MVMint8 tmp = MVM_jit_register_alloc(tc, compiler, MVM_JIT_X64_GPR);
            | mov64 Rq(tmp), val;
            | and Rq(in1), Rq(tmp);
            MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
        } else {
            | and Rq(in1), val;
        }
    } else {
        if (values[2]->size == 8 && !fits_in_32_bit(val)) {
            | mov64 Rq(out), val;
            | and Rq(out), Rq(in1);
        } else {
            | mov Rq(out), Rq(in1);
            | and Rq(out), val;
        }
    }
}

MVM_JIT_TILE_DECL(and_load_mem) {
    MVMint8 out = values[0]->u.reg.num;
    MVMint8 in1 = values[1]->u.reg.num;
    MVMint8 base = values[2]->u.mem.r0;
    if (in1 != out) {
        | mov Rq(out), in1;
    }
    if (values[2]->u.mem.r1 < 0) {
        MVMint32 ofs = values[2]->u.mem.c;
        switch (values[2]->size) {
        case 1:
            | and Rb(out), byte [Rq(base)+ofs];
            break;
        case 2:
            | and Rw(out), word [Rq(base)+ofs];
            break;
        case 4:
            | and Rd(out), dword [Rq(base)+ofs];
            break;
        case 8:
            | and Rq(out), qword [Rq(base)+ofs];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    } else {
        MVMint8  idx = values[2]->u.mem.r1;
        MVMint32 scl = values[2]->u.mem.c;
        if (scl != 8)
            MVM_oops(tc, "IDX Scale %d NYI\n", scl);
        switch (values[2]->size) {
        case 1:
            | and Rb(out), byte [Rq(base)+Rq(idx)*8];
            break;
        case 2:
            | and Rw(out), word [Rq(base)+Rq(idx)*8];
            break;
        case 4:
            | and Rd(out), dword [Rq(base)+Rq(idx)*8];
            break;
        case 8:
            | and Rq(out), qword [Rq(base)+Rq(idx)*8];
            break;
        default:
            MVM_oops(tc, "Unsupported load size: %d\n", values[2]->size);
        }
    }
}


MVM_JIT_TILE_DECL(nz_reg) {
    MVMint8 reg = values[1]->u.reg.num;
    | test Rq(reg), Rq(reg);
}


MVM_JIT_TILE_DECL(nz_mem) {
    MVMint8 base = values[1]->u.mem.r0;
    MVMint8 idx  = values[1]->u.mem.r1;
    if (idx < 0) {
        MVMint32 ofs = values[1]->u.mem.c;
        switch (values[1]->size) {
        case 1:
            | cmp byte [Rq(base)+ofs], 0;
            break;
        case 2:
            | cmp word [Rq(base)+ofs], 0;
            break;
        case 4:
            | cmp dword [Rq(base)+ofs], 0;
            break;
        case 8:
            | cmp qword [Rq(base)+ofs], 0;
            break;
        default:
            MVM_oops(tc, "Unsupported size %d for load\n", values[1]->size);
        }
    } else {
        MVMint32 scale = values[1]->u.mem.c;
        if (scale != 8)
            MVM_oops(tc, "Scale %d NYI\n", scale);
        switch(values[1]->size) {
        case 1:
            | cmp byte [Rq(base)+Rq(idx)*8], 0;
            break;
        case 2:
            | cmp word [Rq(base)+Rq(idx)*8], 0;
            break;
        case 4:
            | cmp dword [Rq(base)+Rq(idx)*8], 0;
            break;
        case 8:
            | cmp qword [Rq(base)+Rq(idx)*8], 0;
            break;
        default:
            MVM_oops(tc, "Unsupported size %d for load\n", values[1]->size);
        }
    }
}

MVM_JIT_TILE_DECL(nz_and) {
    MVMint8 rega = values[1]->u.reg.num;
    MVMint8 regb = values[2]->u.reg.num;
    switch(values[0]->size) {
    case 1:
        | test Rb(regb), Rb(rega);
        break;
    case 2:
        | test Rw(regb), Rw(rega);
        break;
    case 4:
        | test Rd(regb), Rd(rega);
        break;
    case 8:
        | test Rq(regb), Rq(rega);
        break;
    }
}


/* Placeholder tiles. Not very good to implement as postorder expressions (yet) */
MVM_JIT_TILE_DECL(all) {
    /* not implemented as a tile */
}

MVM_JIT_TILE_DECL(if) {
    /* NYI */
}

MVM_JIT_TILE_DECL(when) {
    /* not implemented as a tile */
}

MVM_JIT_TILE_DECL(do_reg) {
    /* not really a tile */
}

MVM_JIT_TILE_DECL(do_void) {
    /* not really a tile */
}


MVM_JIT_TILE_DECL(label) {
    values[0]->u.label = values[1]->u.const_val;
}

MVM_JIT_TILE_DECL(label_addr) {
    MVMint8 reg = values[0]->u.reg.num;
    MVMint32 label = values[1]->u.const_val;
    | lea Rq(reg), [=>label];
}

MVM_JIT_TILE_DECL(branch_label) {
    MVMint32 label = values[1]->u.label;
    | jmp =>(label);
}

MVM_JIT_TILE_DECL(when_branch) {
    MVMint32 op = tree->nodes[tree->nodes[node+1]];
    MVMint32 label  = values[2]->u.label;
    switch (op) {
    case MVM_JIT_LT:
        | jl =>(label);
        break;
    case MVM_JIT_LE:
        | jle =>(label);
        break;
    case MVM_JIT_EQ:
        | je =>(label);
        break;
    case MVM_JIT_NE:
        | jne =>(label);
        break;
    case MVM_JIT_GE:
        | jge =>(label);
        break;
    case MVM_JIT_GT:
        | jg =>(label);
        break;
    case MVM_JIT_NZ:
        | jnz =>(label);
        break;
    case MVM_JIT_ZR:
        | jz =>(label);
        break;
    default:
        MVM_oops(tc, "this should not be dealt with here");
    }
}

MVM_JIT_TILE_DECL(callfunc) {
    /* lets assume that arglist has already worked... */
    MVMint64 constptr = values[1]->u.const_val;
    MVMint8 tmp = MVM_jit_register_alloc(tc, compiler, MVM_JIT_X64_GPR);
    if (!fits_in_32_bit(constptr)) {
        | mov64 Rq(tmp), constptr;
    } else {
        | mov Rq(tmp), constptr;
    }
    | call Rq(tmp);
    MVM_jit_register_free(tc, compiler, MVM_JIT_X64_GPR, tmp);
}

MVM_JIT_TILE_DECL(callreg) {
    MVMint8 reg = values[1]->u.reg.num;
    | call Rq(reg);
}
