#+STARTUP: showeverything
* Register allocator plan

Currently, multiple live ranges can inhabit the same location (due to
copies, IF resolution, etc). This is problematic, and results from the
fact that we only allow a single definition per live range. This
significantly complicates handling stores and loads.

The better approach is to allow multiple definitions per live range,
which makes it stand for the entire life of a single variable. These
definitions can be found by using the disjoint-set algorithm,
combining values via PHI (or in our case, COPY/DO/IF nodes). This
makes sense as (preferably) all these values use the same register.



** TODO Remove cruft from previous attempts

- we don't need MVMJitValue anymore (yay, no more value types)
  - instead we can assign register addresses directly to tiles (8 bits
    is sufficient)
- we don't need double-linked lists either, because live ranges now
  contain their own set
- tile editor code moves to tile.c
  - keep it abstract?
  - internalize into list? (why not?)


** TODO Find live ranges

I think we can do this in a single pass, or maybe two passes

- to implmeent disjoint-set we build a union-find array
  - each thing is initially in it's own set
  - the key of the set is the number of the node it refers to
  - at phis/copies, we pick the set with the lowest key / largest
    definition set (whichever we know easier)
- definitions and uses are tile-list indexes
- we still need a tile-to-live-range map
  - we can just run get_nodes() again and again...
- we use a second pass to find all definitions and uses (maybe keep
  counts of these)
  - if we do it in the first pass, the uses/definitions are going to
    refer to possibly-merged sets, so we have to resolve those during
    the later passes; it's easier to do so earlier,
  - if we count the number of uses and definitions in the first pass
    we can simply store them in a single buffer in the second pass
- to split a live range (at a given point), we must
  - split both uses and definitions
  - if these placed in ascending order in a single buffer, we can
    split that buffer without copying (in most cases)
  - the exception is if a single conditional branch of a definition is
    split off, since it may be 'inbetween' the buffer, but we can fix
    that by shuffling (in principle)
  - point all the uses in the split live range to the new live range

*** TODO Represent value yielding efficiently

We currently rely on inspecting the template to see if the thing
yields a value. However, yielding a value is specific to a tile not
its template.

This is also related to the issue of specifying register preferences.
We want to specify that a certain tile takes certain input registers
and yields an output register. And I think we can do this with a
bitmap, so let's design that.

Suppose we allow 4 register inputs (currently 8, but this is only
relevant for ARGLIST, which can be dealt with specifically in some
other context).

And suppose we allow for 32 different register locations to be
specified (5 bits per register).  That gives us 4 bits + 20 bits = 24
bits....  We can be 'richer' and allow 6 bits per register * 4 + 4
bits is still just 28 bits. If we allow 8 registers - no reason to,
but let's suppose so, then 48 + 8 = 54 bits necessary, i.e., fits in a
single 64 bit quadword. But I think 32 bits are quite sufficient.

Note that the 6 bits is sufficient to specify register class (on
x86-64) as well as register specification.

Using the convention that the zeroth register is the output register
is an output register, we can use the remaining 4 bits to specify
whether the registers are actually used and/or whether we require a
scratch register. For example [[http://x86.renejeschke.de/html/file_module_x86_id_137.html][idiv]]:



#+BEGIN_EXAMPLE


  0b1110 # use registers 0-2
  0b1110 # specify registers 0-2
  0b000000 # register 0 = rax (0)
  0b000000 # register 1 = rax (0)
  0b000001 # register 2 = rcx (1)
  0b000000 # regsiter 3 = unused

#+END_EXAMPLE

or jmp (register variant or memory-by-register variant):

#+BEGIN_EXAMPLE

0b0100 # use register 1
0b0000 # nothing specific
0b000000 # (x 4)

#+END_EXAMPLE

or pop (which reads from rsp but writes to any register):

#+BEGIN_EXAMPLE
0b1100 # rsp is implicit (and can't be allocated), but for the sake of example
0b0100 # specify only the read register
0b00000 # can be anything
0b00100 # rsp, iirc, is register 4, rbp is register 5
#+END_EXAMPLE

The 'yields value' is now simply 'is the highest significant bit
set'. Or lowest... depending on where we place it. And 'do we need a
scratch register' is just 'is register 4 set'.v

The idea is to specify these requirements using macro composition.


If this is ever insufficient, we can move to a larger representation;
complexity of tiles is inversely correlated with complexity of
register requirements (CISC vs RISC), so I'm nto too worried.


** TODO Implement linear scan

The basic idea of linear scan is:
- iterate over live ranges in order of first definition
  - if any of the current live range is dead, remove it from the
    current live set (so that their register becomes free for the new
    live set)
  - assign them to current live set
  - if the live range has a prefered register
    - if this prefered register is taken
      - then we have a conflict (resolve by spilling/splitting)
      - else assign the prefered register to that live range

- assign registers in a second pass

  - reuse the register assignment ring buffer
  - we've already dealt with prefered-register conflicts in the
    earlier step, so we can always assign the prefered register
  - if the prefered register is already taken, then we can take
    another register and swap it with its' current holder, which is
    guaranteed to be possible.

The current live set can be implemented as a heap of integers pointing
to the live range array. This may be preferable to the current
insertion-sorted array because spilling is rare and this pessimizes
the expire-register case.....

Maybe we should have the prefered-register thing per use/defintiion,
but that becomes very complicated fast.

*** TODO Implement spilling

Spilling is implemented by inserting stores (if not present) after
every definition and loads before every use. Many operations actually
have stores appended (I haven't optimized them away, yet), so it may
never be necessary to insert the spill code. But we still need to
insert loads.

A byproduct of this method is that we must leave a number of registers
free to load spilled values; three is sufficient for x86-64.

*** TODO Implement splitting

One might split a live range in two, for example, if a set of uses
preceeds the point where the range would need to be spilled; the value
may reside in the register before the spill and reside in storage
afterwards.

** TODO register assignment
