#+STARTUP: showeverything
* Register allocator plan

Currently, multiple live ranges can inhabit the same location (due to
copies, IF resolution, etc). This is problematic, and results from the
fact that we only allow a single definition per live range. This
significantly complicates handling stores and loads.

The better approach is to allow multiple definitions per live range,
which makes it stand for the entire life of a single variable. These
definitions can be found by using the disjoint-set algorithm,
combining values via PHI (or in our case, COPY/DO/IF nodes). This
makes sense as (preferably) all these values use the same register.



** DONE Implement IF/EITHER handling

I am seeing an issue with the node of synthetic tiles. The register
allocator observes this node to see what kind of step it has to take
on e.g. IF nodes.  But we copy these node values into their synthetic
tiles, which has no real value so far as I can see....  

Copying the node into the tile will cause issues currently because
we cannot distinguish between the postorder 'resolution' `IF` tile and
the synthetic inorder `IF` tiles, except that the latter has a pointer to
a template and the former does not.

** TODO Get rid of template pointers in the tile object

This is a far-too-brittle construction that artificially distinguishes
between 'real' tiles and pseudotiles, and there is no reason to have them,
except that (in some places) we rely on the difference. An unintended
consequence is that it is complex to add pseudotiles that refer to
live ranges (like loads and spills) with reference to the live ranges
they affect, because (currently) these live ranges are refered to by
tree node extraction, and pseudotiles don't do that. It is,
altogether, brittle.

The suggested solution is to move tree extraction to an earlier tiling
step (postorder, so the tree can't change underneath from tile
conflict resolution) and to use the existing args buffer for this
purpose. We can then separate live ranges from args using compaction.

A further requirement is a correct way to distinguish between
postorder and inorder tiles.

** TODO Remove cruft from previous attempts

- we don't need MVMJitValue anymore (yay, no more value types)
  - instead we can assign register addresses directly to tiles (8 bits
    is sufficient)
- we don't need double-linked lists either, because live ranges now
  contain their own set
** DONE tile editor code moves to tile.c
  - keep it abstract?
  - internalize into list? (why not?)


** TODO Find live ranges

I think we can do this in a single pass, or maybe two passes

- to implmeent disjoint-set we build a union-find array
  - each thing is initially in it's own set
  - the key of the set is the number of the node it refers to
  - at phis/copies, we pick the set with the lowest key / largest
    definition set (whichever we know easier)
- definitions and uses are tile-list indexes
- we still need a tile-to-live-range map
  - we can just run get_nodes() again and again...
  - nope, we really can't; we need to insert and maintain 'synthetic' live nodes
- we use a second pass to find all definitions and uses (maybe keep
  counts of these)
  - if we do it in the first pass, the uses/definitions are going to
    refer to possibly-merged sets, so we have to resolve those during
    the later passes; it's easier to do so earlier,
  - if we count the number of uses and definitions in the first pass
    we can simply store them in a single buffer in the second pass
- to split a live range (at a given point), we must
  - split both uses and definitions
  - if these placed in ascending order in a single buffer, we can
    split that buffer without copying (in most cases)
  - the exception is if a single conditional branch of a definition is
    split off, since it may be 'inbetween' the buffer, but we can fix
    that by shuffling (in principle)
  - point all the uses in the split live range to the new live range

*** TODO Represent register requirements intelligently

We currently rely on inspecting the template to see if the thing
yields a value. However, yielding a value is specific to a tile not
its template.

This is also related to the issue of specifying register preferences.
We want to specify that a certain tile takes certain input registers
and yields an output register. And I think we can do this with a
bitmap, so let's design that.

Suppose we allow 4 register inputs (currently 8, but this is only
relevant for ARGLIST, which can be dealt with specifically in some
other context).

And suppose we allow for 32 different register locations to be
specified (5 bits per register).  That gives us 4 bits + 20 bits = 24
bits....  We can be 'richer' and allow 6 bits per register * 4 + 4
bits is still just 28 bits. If we allow 8 registers - no reason to,
but let's suppose so, then 48 + 8 = 54 bits necessary, i.e., fits in a
single 64 bit quadword. But I think 32 bits are quite sufficient.

Note that the 6 bits is sufficient to specify register class (on
x86-64) as well as register specification. This gives us a total of 8
bits, or one byte, per register. We can then scale linearly up to the
number of bits required.

#+BEGIN_SRC c
#define MVM_JIT_REGISTER_ENCODE(req,nr) (1 | ((req) << 1) | ((nr) << 2))
#define MVM_JIT_REGISTER_SPEC(a,b,c,d) ((a &0xff) | ((b &0xff) << 8) | ((c & 0xff) << 16) | ((d & 0xff) << 24))
#define MVM_JIT_REGISTER_FETCH(spec,n) ((spec >> (8*n))&0xff)
#define MVM_JIT_REGISTER_NONE 0

#define MVM_JIT_REGISTER_IS_USED(desc) (desc & 1)
#define MVM_JIT_REGISTER_HAS_REQUIREMENT(desc) ((desc & 2) >> 1)
#define MVM_JIT_REGISTER_REQUIREMENT(desc) ((desc & 0xfc) >> 2)

/* we could also do */
ostruct registerspec {
    int used : 1;
    int has_requirement : 1;
    int required_register : 6;
};
/* but this is 4 bytes wide */
#+END_SRC

So the second question is how are we going to encode this in the tile
texts? My initial guess was to add an extra list; but we already
specify which things are registers in the tile itself, and we can just
add it as an attribute.

So we can get (for instance):

#+BEGIN_EXAMPLE
(tile: div (div reg:rax reg:rcx) reg:rax)
(tile: mod (mod reg:rax reg:rcx) reg:rcx)
#+END_EXAMPLE

Fortunately, we have two-operand mul these days, so it needs no
specific treatment, although full-precision (i.e. two-registers
rax:rdx pair) can't be done.

** TODO Implement linear scan

The basic idea of linear scan is:
- iterate over live ranges in order of first definition
  - if any of the current live range is dead, remove it from the
    current live set (so that their register becomes free for the new
    live set)
  - assign them to current live set
  - if the live range has a prefered register
    - if this prefered register is taken
      - then we have a conflict (resolve by spilling/splitting)
      - else assign the prefered register to that live range

NB; Even though we have created the list of live ranges in sorted
order, we'll want to use it as a binary heap, because we can cheaply
maintain the heap property - it is already initialized that way -
while inserting new live ranges (for loading spilled values).

- assign registers in a second pass

  - reuse the register assignment ring buffer
  - we've already dealt with prefered-register conflicts in the
    earlier step, so we can always assign the prefered register
  - if the prefered register is already taken, then we can take
    another register and swap it with its' current holder, which is
    guaranteed to be possible.

The current live set can be implemented as a heap of integers pointing
to the live range array. This may be preferable to the current
insertion-sorted array because spilling is rare and this pessimizes
the expire-register case.....

Maybe we should have the prefered-register thing per use/defintiion,
but that becomes very complicated fast.

*** TODO Implement spilling

Spilling is implemented by inserting stores (if not present) after
every definition and loads before every use. Many operations actually
have stores appended (I haven't optimized them away, yet), so it may
never be necessary to insert the spill code. But we still need to
insert loads.

A byproduct of this method is that we must leave a number of registers
free to load spilled values; three is sufficient for x86-64. (OR we
generate new live ranges for the just-loaded values, which
automatically does the right thing as well.)

*** TODO Implement splitting

One might split a live range in two, for example, if a set of uses
preceeds the point where the range would need to be spilled; the value
may reside in the register before the spill and reside in storage
afterwards.

So in fact, splitting implies:
- taking all definitions/uses within some range
- creating a new live range for range splitted of, inserting it in the
  live range heap (hence a heap!)
- and spill the necessary registers.


*** TODO Precoloring

Comes down to:
- maintaining a table of last-register-used to register-preferences
- assigning a prefered register to certain live ranges
  - if a conflict is present for a single live range, split it (and
    insert a copy between)
  - if a conflict is present between multiple live ranges, spill (one
    of) them

- an output register is fundamentally different from an input register:
  - output single-live-range conflict (multiple definitions different prefered output):
    - pick one, split off the other, insert a copy between them
  - input single-live-range conflict (different prefered register for output/input)
    - split off output range from input range; copy to output range
      (if not spilled)

  - multiple live-range register conflict

    - first-defined output register /must/ be spilled in order to make room for second registe

      - exception: lifetime holes

    - output-input conflict

      - output-register must be copied off /or/ spilled



** TODO register assignment

This should not be a problem, it's just a final loop that assigns
registers according to some scheme. The only 'tricky' bit is to make
sure that prefered registers can actually be assigned. And the way to
do that is to maintain a table of register to live range, and to
/swap/ prefered registers which have been accidentally assigned to
other live ranges. This is *always possible* since splitting and
spilling has made sure of it.
